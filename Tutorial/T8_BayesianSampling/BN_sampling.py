from random import random

'''
Simple implementation for 'standard' Bayes Net Sampling
Based on the example in the lecture note

Instructiosn:
first create a BNSampling object:
	net = BNSampling()

second do N samples by calling object function 'BN_sampling'
the function will takes an optional integer argument 'n', the number of samples
n is default to 1000
the function return a list of samples generated by standard sampling
	samples = net.BN_sampling(n=10000000)

third, find the probability of certain events by calling the object function 'approximate_event' with generated samples from previous step
the function takes an optional dictionary argument 'events={}'
valid keys are 'c', 's', 'r', 'w'
valid values are 1, 0
ie: events={'c':1, 's':0}
ie: events={'c':1, 's':1, 'r':1, 'w':0}
function will return the probability of the given event happens
function will return 0 if the events is not given
	prob = net.approximate_event(samples, events={'c':1, 's':0})

One example is provided in the main function...
Thank you and stay safe!
'''


class BNSampling:
    def __init__(self):
        self.probabilities = {'c=0': 0.7, 'c=1': 0.3,
                              's=0|c=0': 0.8, 's=0|c=1': 0.5, 's=1|c=0': 0.2, 's=1|c=1': 0.5,
                              'r=0|c=0': 0.99, 'r=0|c=1': 0.2, 'r=1|c=0': 0.01, 'r=1|c=1': 0.8,
                              'w=0|s=0,r=0': 0.99, 'w=0|s=0,r=1': 0.1, 'w=0|s=1,r=0': 0.05, 'w=0|s=1,r=1': 0.01,
                              'w=1|s=0,r=0': 0.01, 'w=1|s=0,r=1': 0.9, 'w=1|s=1,r=0': 0.95, 'w=1|s=1,r=1': 0.99
                              }
        self.variables = ['c', 's', 'r', 'w']

    def BN_sampling(self, n=1000, observed=[]):
        res_table = []
        for i in range(n):
            sample = {}
            # sampel c
            rc = random()
            if(rc < self.probabilities['c=0']):
                sample['c'] = 0
            else:
                sample['c'] = 1
            # sample s
            rs = random()
            if(sample['c'] == 0):
                if(rs < self.probabilities['s=0|c=0']):
                    sample['s'] = 0
                else:
                    sample['s'] = 1
            else:
                if(rs < self.probabilities['s=0|c=1']):
                    sample['s'] = 0
                else:
                    sample['s'] = 1
            # sample r
            rr = random()
            if(sample['c'] == 0):
                if(rr < self.probabilities['r=0|c=0']):
                    sample['r'] = 0
                else:
                    sample['r'] = 1
            else:
                if(rr < self.probabilities['r=0|c=1']):
                    sample['r'] = 0
                else:
                    sample['r'] = 1
            # sample w
            rw = random()
            if(sample['s'] == 0 and sample['r'] == 0):
                if(rw < self.probabilities['w=0|s=0,r=0']):
                    sample['w'] = 0
                else:
                    sample['w'] = 1
            elif(sample['s'] == 0 and sample['r'] == 1):
                if(rw < self.probabilities['w=0|s=0,r=1']):
                    sample['w'] = 0
                else:
                    sample['w'] = 1
            elif(sample['s'] == 1 and sample['r'] == 0):
                if(rw < self.probabilities['w=0|s=1,r=0']):
                    sample['w'] = 0
                else:
                    sample['w'] = 1
            else:
                if(rw < self.probabilities['w=0|s=1,r=1']):
                    sample['w'] = 0
                else:
                    sample['w'] = 1
            res_table.append(sample)
        return res_table

    def approximate_event(self, samples, events={}):
        if(len(events) == 0):
            print('I say probability of no event happen is 0!!')
            return 0
        else:
            count = 0
            for sample in samples:
                match = True
                for event in events:
                    if(sample[event] != events[event]):
                        match = False
                if(match):
                    count = count + 1
            return float(count) / len(samples)


if __name__ == '__main__':
    b = BNSampling()
    samples = b.BN_sampling(n=1000000)
    prob = b.approximate_event(samples, events={'c': 1, 's': 1})
    print(prob)
